flag_checker
====================

![image](https://github.com/user-attachments/assets/4ddf41fe-6792-4bf1-a285-9b386728951f)

먼저 파일의 형식을 체크하기 위해 헥스 에디터에서 파일을 연다.

주어진 파일은 **elf 파일**이다.

![image](https://github.com/user-attachments/assets/47724b08-3af4-478f-b285-ead9c91cc00a)

확장자를 바꾼 후 ida에서 파일을 열어 main함수를 찾아본다. main을 디컴파일한 결과를 분석하면

1. **`char s[40]; `:**
    * `s`라는 40 바이트 크기의 문자 배열이 스택에 할당되어 사용자로부터 입력받은 문자열을 저장하는 데 사용된다.

2.  **`unsigned __int64 v5; `:**
    * `v5`라는 8바이트 크기의 부호 없는 64비트 정수형 변수가 스택에 할당된다.

3.  **`v5 = __readfsqword(0x28u);`:**
    * `__readfsqword(0x28u)`는 FS 세그먼트 레지스터의 오프셋 `0x28`에 위치한 8바이트 값을 읽어와 `v5`에 저장한다.
    뭐하는 동작인지 찾아보니 스택 버퍼 오버플로우 공격을 방지하기 위한 메커니즘의 일부라고 한다.

4.  **`printf("Enter the flag: ");`:**
    * 표준 출력 스트림(`stdout`)에 "Enter the flag: "라는 문자열을 출력하여 사용자에게 플래그 입력을 요청한다.

5.  **`fgets(s, 35, stdin);`:**
    * 표준 입력 스트림(`stdin`)으로부터 최대 34개의 문자 (널 종료 문자 포함해서 35개)를 읽어와 문자 배열 `s`에 저장한다.
    * `fgets`는 개행 문자(`\n`)를 읽으면 읽기를 멈추고, 읽은 개행 문자를 문자열에 포함시킨다. 

6.  **`s[strcspn(s, "\n")] = 0;`:**
    * `strcspn(s, "\n")` 함수는 문자열 `s`에서 문자열 \n에 포함된 어떤 문자라도 처음으로 나타나는 위치의 인덱스를 반환한다. 즉 입력 문자열에서 첫 번째 개행 문자의 위치를 찾는다.
    * `s[strcspn(s, "\n")] = 0;`는 찾은 개행 문자(`\n`)를 널 종료 문자(`\0`)로 덮어쓴다. 만약 입력에 개행 문자가 없다면, `strcspn`은 문자열의 끝 인덱스를 반환하고, 마지막 문자가 널 종료된다 (입력이 34자로 꽉 찬 경우).

7.  **`if ( (unsigned int)sub_127A(s) )`:**
    * `sub_127A(s)` 함수를 호출하고, 사용자 입력 문자열 `s`를 인자로 전달한다.
    * 함수의 반환 값은 `(unsigned int)`로 캐스팅되어 반환 값이 부호 없는 정수형으로 처리된다.
    * `if` 조건문은 `sub_127A(s)`의 반환 값이 0이 아닌 경우 (참인 경우)에 `puts("Correct!");`를 실행한다.

8.  **`puts("Correct!");`:**
    * `sub_127A` 함수가 0이 아닌 값을 반환하면 표준 출력 스트림에 "Correct!"라는 문자열을 출력한다.

9. **`else puts("Incorrect!");`:**
    * `sub_127A` 함수가 0을 반환하면 표준 출력 스트림에 "Incorrect!"라는 문자열을 출력한다.




 sub_127A 함수를 찾아보면

 ![image](https://github.com/user-attachments/assets/9ae9284a-801f-4814-b82b-1dca5d960b76)

코드를 분석해보면

1.  **`int i; `:**
    * 정수형 변수 `i`가 루프 카운터로 사용될 것이다.

2.  **`_BYTE v3[40]; `:**
    * 40 바이트 크기의 바이트 배열 `v3`가 스택에 할당된다. 이 배열은 `sub_11E9` 함수의 결과를 저장하는 데 사용될 것으로 보인다.

3.  **`unsigned __int64 v4; `:**
    * 스택 쿠키를 저장하는 변수이다.

4.  **`v4 = __readfsqword(0x28u);`:**
    * 스택 쿠키를 읽어와 `v4`에 저장한다.

5.  **`if ( strlen(a1) != 34 ) return 0LL;`:**
    * `strlen(a1)` 함수를 사용하여 입력 문자열 `a1`의 길이를 계산한다.
    * 만약 입력 문자열의 길이가 34가 아니면 함수는 `0LL` (거짓)을 반환한다. 플래그의 길이가 정확히 34 바이트여야 함을 의미한다.

6.  **`sub_11E9(a1, v3);`:**
    * `sub_11E9`라는 또 다른 함수를 호출한다.
    * 사용자 입력 문자열 `a1`과 바이트 배열 `v3`의 주소를 인자로 전달한다.
    * `sub_11E9` 함수에서 입력 문자열 `a1`을 어떤 방식으로든 변환하거나 처리하여 그 결과를 `v3` 배열에 저장한다.

7.  **`for ( i = 0; i <= 33; ++i )`:**
    * 0부터 33까지 (총 34번) 반복하는 `for` 루프를 실행한다.

8.  **`if ( v3[i] != byte_2020[i] ) return 0LL;`:**
    * 루프 내에서 `v3` 배열의 각 바이트 (`v3[i]`)와 `byte_2020`이라는 전역 바이트 배열의 해당 바이트 (`byte_2020[i]`)를 비교한다.
    * 만약 어느 한 바이트라도 서로 다르다면 함수는 즉시 `0LL` (거짓)을 반환한다.

9. **`return 1LL;`:**
    * `for` 루프가 34번 모두 성공적으로 완료되면 (즉, `v3` 배열의 모든 바이트가 `byte_2020` 배열의 해당 바이트와 같다면), 함수는 `1LL` (참)을 반환한다.

결론적으로 `sub_127A` 함수가 플래그를 검증하는 과정은


1.  **길이 검사:** 입력된 플래그의 길이가 정확히 34 바이트여야 한다.
2.  **변환:** 입력된 플래그는 `sub_11E9` 함수를 통해 변환된다. 변환된 결과는 `v3` 배열에 저장된다.
3.  **비교:** `v3` 배열의 각 바이트는 `byte_2020`이라는 전역 바이트 배열의 해당 바이트와 일대일로 비교되어 모든 바이트가 일치해야 하는지 확인된다.


그러면 이제 `sub_11E9` 함수를 찾으면 

![image](https://github.com/user-attachments/assets/9fefbafa-9a15-4e02-a43c-a2c0555ed6c8)

1.  **`int i; // [rsp+1Ch] [rbp-4h]`:**
    * 정수형 변수 i는 for 루프의 인덱스로 사용된다.

2.  **`for ( i = 0; i <= 33; ++i )`:**
    * 0부터 33까지 (총 34번) 반복하는 for 루프이다.

4.  **`*(_BYTE *)(i + a2) = (*(_BYTE *)(i + a1) ^ 0x5A) + i;`:**
    * 이 줄은 입력 플래그의 각 바이트를 변환하여 결과 배열 `a2`에 저장하는 연산이다.
        * `*(_BYTE *)(i + a1)`: 입력 플래그 `a1`의 `i`번째 바이트를 읽어온다.
        * `^ 0x5A`: 읽어온 바이트와 16진수 값 `0x5A` (십진수 90)를 **비트 XOR 연산** 한다.
        * `+ i`: XOR 연산의 결과에 현재 루프 인덱스 i 값을 더한다.
        * `*(_BYTE *)(i + a2) = ...`: 계산된 최종 값을 결과 배열 a2의 i번째 바이트에 저장한다.

5.  **`result = (_BYTE *)(i + a2);`:**
    * `result` 포인터에 현재 결과 배열의 바이트 주소 (`a2 + i`)를 할당한다.
      루프가 진행됨에 따라 `result`는 계속 업데이트되어 마지막 바이트의 주소를 가리키게 된다.

6.  **`*result = (*result >> 5) | (8 * *result);`:**
    * 이 줄은 결과 배열 `a2`에 저장된 바이트에 대해 추가적인 비트 연산을 수행한다.
        * `*result`: 현재 `result` 포인터가 가리키는 바이트 (즉, `a2[i]`)의 값을 읽어온다.
        * `*result >> 5`: 읽어온 바이트를 **오른쪽으로 5비트 시프트** 한다.
          하위 5비트가 버려지고 상위 3비트가 하위 3비트로 이동하며, 최상위 5비트는 0으로 채워진다.
        * `8 * *result`: 읽어온 바이트에 8을 곱한다. 이는 왼쪽으로 3비트 시프트하는 것과 동일하다 (`<< 3`).
        * `|`: 오른쪽 시프트 결과와 왼쪽 시프트 결과를 **비트 OR 연산** 한다.
        * `*result = ...`: 최종 결과를 다시 현재 `result` 포인터가 가리키는 바이트 (`a2[i]`)에 저장한다.

7.  **`return result;`:**
    * 루프가 완료된 후, 결과 배열의 마지막 바이트 주소를 가리키는 `result` 포인터를 반환한한다.


요약하자면 `sub_11E9` 함수는 입력 플래그의 각 바이트에 대해 다음 두 가지 연산을 순차적으로 수행한다.

1.  **XOR 및 덧셈:** 입력 바이트와 `0x5A`를 XOR 연산한 후, 현재 인덱스 i 값을 더한다.
2.  **비트 시프트 및 OR 연산:** 이전 단계의 결과 바이트를 오른쪽으로 5비트 시프트한 값과 왼쪽으로 3비트 시프트한 값을 OR 연산한다.

이러한 변환을 거친 34 바이트의 결과가 `v3` 배열에 저장되고, 이후 `sub_127A` 함수에서 이 `v3` 배열의 내용이 `byte_2020` 배열과 비교되어 플래그의 정답 여부가 판별된다.

`sub_127A` 함수에서 클릭해서 `byte_2020` 배열을 확인하면 

![image](https://github.com/user-attachments/assets/169951ee-6ba0-4d78-8c73-2921d7fab922)


0xF8, 0xA8, 0xB8, 0x21, 0x60, 0x73, 0x90, 0x83, 0x80, 0xC3, 0x9B, 0x80, 0xAB, 
0x09, 0x59, 0xD3, 0x21, 0xD3, 0xDB, 0xD8, 0xFB, 0x49, 0x99, 0xE0, 
0x79, 0x3C, 0x4C, 0x49, 0x2C, 0x29, 0xCC, 0xD4, 0xDC, 0x42
임을 확인할 수 있다.


 이제 이 정보들을 이용해서 플래그를 추출하는 코드를 작성한다.



```python

 def ror8(val, r_bits):
    """8비트 기준 rotate right"""
    return ((val >> r_bits) | (val << (8 - r_bits))) & 0xFF

def reverse_transform(output_bytes):
    input_flag = []
    for i in range(34):
        temp = ror8(output_bytes[i], 3)      # rol8 해제 → ror8(3)
        original = (temp - i) ^ 0x5A          # -index → XOR 0x5A
        input_flag.append(original & 0xFF)
    return bytes(input_flag)

cipher_bytes = [
    0xF8, 0xA8, 0xB8, 0x21, 0x60, 0x73, 0x90, 0x83, 0x80, 0xC3,
    0x9B, 0x80, 0xAB, 0x09, 0x59, 0xD3, 0x21, 0xD3, 0xDB, 0xD8,
    0xFB, 0x49, 0x99, 0xE0, 0x79, 0x3C, 0x4C, 0x49, 0x2C, 0x29,
    0xCC, 0xD4, 0xDC, 0x42
]

flag = reverse_transform(cipher_bytes)
print(flag.decode())

```

암호화 과정이 (input_byte ^ 0x5A) + index -> (result >> 5) | (result << 3) 이었으므로

복호화 과정은 ror8(output_byte, 3) -> (temp - index) ^ 0x5A 


저장해서 실행하면

![image](https://github.com/user-attachments/assets/eeeb0d7b-f8ae-47c2-b0a6-869d8911774a)

따라서 플래그는 **ENO{R3V3R53_3NG1N33R1NG_M45T3R!!!}** 

