2025 하계스터디 시스템해킹 1주차: 함수 호출 규약
====================================

1.함수 호출 규약이란
-------------------

* 함수 호출 규약은 함수가 호출되고 반환될 때의 약속이다.
* 호출자(Caller)는 피호출자(Callee)에게 인자를 전달하고, 피호출자는 실행 후 값을 반환한다.
이를 위해 호출자는 스택 상태(Stack frame)와 복귀 주소(Return Address)를 저장해야 한다.
* 컴파일러가 CPU 아키텍처에 맞는 호출 규약을 선택하므로 일반 프로그래머는 이를 명시적으로 알 필요는 없다.
그러나 어셈블리 코드를 직접 다룰 때는 호출 규약을 알아야 한다.


2.x86호출 규약
-----------------------

* 전통적인 x86에서는 모든 매개변수를 스택을 통해 전달했다.
* x86-64로 확장되면서 스택보다 빠른 레지스터를 적극적으로 활용하게 되었다.
* 현대의 함수 호출 규약은 레지스터와 스택을 함께 사용한다.

-------------------

## 컴파일러와 CPU 아키텍처에 따른 호출 규약 선택

* 컴파일러는 CPU 아키텍처에 맞는 호출 규약을 선택한다.
* x86 (32bit) 아키텍처는 레지스터 수가 적어 스택으로 인자를 전달하는 규약을 선호한다.
* x86-64 아키텍처는 레지스터가 많기 때문에 적은 수의 인자는 레지스터로 전달하고, 인자가 많을 때 스택을 사용한다.
* CPU 아키텍처가 같더라도 컴파일러(예: MSVC vs gcc)에 따라 적용하는 호출 규약이 다를 수 있다.
x86-64에서 MSVC는 MS x64 호출 규약을 사용하고, gcc는 SYSTEM V 호출 규약을 사용한다.

----------------------

## cdecl (C Declaration)


```assembly
; Name: cdecl.s
	.file	"cdecl.c"
	.intel_syntax noprefix
	.text
	.globl	callee
	.type	callee, @function
callee:
	nop
	ret
	.size	callee, .-callee
	.globl	caller
	.type	caller, @function
caller:
	push	3 ; 3을 스택에 저장하여 callee의 인자로 전달
	push	2 ; 2를 스택에 저장하여 callee의 인자로 전달
	push	1 ; 1을 스택에 저장하여 callee의 인자로 전달
	call	callee
	add	esp, 12 ; 호출자가 총 12바이트 만큼 스택을 정리 (push를 3번하였기 때문에 12바이트 만큼 esp가 증가되어 있다.)
	nop
	ret
	.size	caller, .-caller
	.ident	"GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0"
	.section	.note.GNU-stack,"",@progbits
```

* 리눅스 gcc에서 x86 바이너리를 컴파일할 때 일반적으로 사용되는 호출 규약이다.
* 레지스터 없이 스택으로만 인자를 전달한다.
* 인자를 스택에 전달할 때는 마지막 인자부터 첫 번째 인자까지 거꾸로 push 한다.
* 스택 정리는 호출자(caller)가 담당한다. **(예시에서는 add esp, 12로 12바이트 정리)**

------------------------

## stdcall (Standard Call)

```assembly
callee:
    push ebp
    mov ebp, esp
    leave
    retn 12 ; 피호출자가 총 12바이트 만큼 스택을 정리
caller:
    push ebp
    mov ebp, esp
    push 3 ; 3을 스택에 저장하여 callee의 인자로 전달
    push 2 ; 2를 스택에 저장하여 callee의 인자로 전달
    push 1 ; 1을 스택에 저장하여 callee의 인자로 전달
    call callee
    leave
    ret
```

* 윈도우 API(Application Programming Interface)에서 기본적으로 사용되는 함수 호출 규약이다.
* cdecl과 달리 스택 정리를 피호출자(callee)가 담당한다. **(예시에서는 retn 12로 12바이트 정리)**
* 인자를 스택에 전달할 때는 cdecl과 동일하게 마지막 인자부터 첫 번째 인자까지 거꾸로 push 한다.

-------------------------

## fastcall

```assembly
callee:
    push ebp
    mov ebp, esp
    leave
    retn 4 ; 피호출자가 총 4바이트 만큼 스택을 정리
caller:
    push ebp
    mov ebp, esp
    mov ecx, 1 ; ecx를 통해 1을 callee의 인자로 전달
    mov edx, 2 ; edx를 통해 2를 callee의 인자로 전달
    push 3 ; 3을 스택에 저장하여 callee의 인자로 전달
    call callee
    leave
    ret
```

* 함수 호출 시 일부 인자를 레지스터(ecx, edx)로 전달하여 속도를 향상시킨다.
* 처음 두 개의 인자는 각각 ecx, edx에 전달하고, 나머지 인자는 스택에 마지막부터 전달한다.
* 스택 정리는 피호출자(callee)가 담당하며, retn 4 (4바이트)를 통해 스택을 정리한다. **(예시에서는 retn 4가 4바이트 정리)**

----------------------------------

## thiscall

```c++
class C
{
public:
	int c;
	int foo(int a, int b)
	{
		return c + a + b;
	}
};
```

```assembly
foo:                    ; __thiscall C::foo(int a, int b)
  ...
  mov     eax, [ebp+8] ; eax에 스택에 있는 a의 값 대입
  add     eax, [ebp+12] ; eax에 스택에 있는 b의 값을 더한다.
  add     eax, [ecx] ; eax에 this->c의 값을 더한다.

  leave
  retn    8 ; 피호출자가 총 8바이트 만큼 스택을 정리
```

* thiscall은 x86에서 사용되는 C++ 클래스 멤버 함수를 위한 호출 규약이다.
* **this 포인터 전달:** 멤버 함수에서 사용되는 this 포인터는 ecx 레지스터로 전달된다.
* **나머지 인자 전달:** this를 제외한 나머지 인자들은 모두 스택을 통해 전달된다.
* **스택 정리:** 피호출자(callee)가 스택을 정리한다. (예시에서는 retn 8로 8바이트 정리)


```c++
class C
{
public:
	int c;
    int d;
    unsigned long e;
	int foo(int a, int b)
	{
		return c + d + e + a + b;
	}
};
```

```assembly
foo:                    ; __thiscall C::foo(int a, int b)
  ...
  mov     eax, [ebp+8]
  add     eax, [ebp+12]
  add     eax, [ecx] ; this->c
  add     eax, [ecx+4] ; this->d
  add     eax, [ecx+8] ; this->e

  leave
  retn    8
```

* **멤버 변수 접근:** ecx 레지스터가 this 포인터를 가리키므로, ecx + offset 형태로 클래스의 멤버 변수에 접근할 수 있다. 예시를 보면, this->c는 [ecx], this->d는 [ecx+4], this->e는 [ecx+8]와 같이 접근한다.


3.x86-64호출 규약: SYSV
-------------------------






