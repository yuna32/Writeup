basic_exploitation_000 라이트업
===================================



<img width="378" height="653" alt="image" src="https://github.com/user-attachments/assets/8b15ccdf-999f-41e0-9f5d-f38855038349" />

main 함수를 보면 char 배열 buf에 0X80 바이트를 할당해준다. 이후 initialize 함수를 실행하는데 함수를 보면

```c
    signal(SIGALRM, alarm_handler);
    alarm(30);
```

프로세스가 30초가 지나면 자동으로 alarm_handler 함수를 실행하여 프로세스가 종료된ㄷ.

```c
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);
```

여기서는 스택에서 buf가 위치한 주소를 출력해주고 buf에 최대 141바이트 문자열을 입력받는다. 
buf에는 0x80 =  128바이트만이 할당되어있다. 따라서 **버퍼 오버플로우** 가 발생함을 확인할 수 있다.

스택 위 즉 buf 뒤에 있는 RET, return address를 셸을 실행시키는 기능이 있는 주소로 덮는다면 main 함수가 리턴할때의 
흐름을 바꿔 셸을 실행시킬 수 있을 것이다. 그러나 001 문제와 달리 셸을 실행하는 get_shell 함수가 없어 직접 셸을
실행하는 코드를 주입해야 한다.


<img width="792" height="437" alt="image" src="https://github.com/user-attachments/assets/7ddbc381-ea9d-4661-955a-af5c8c91e009" />


buf는 ebp-0x80 즉 0x80 바이트만큼 베이스 포인터에서 떨어져있다. 

<img width="1007" height="402" alt="image" src="https://github.com/user-attachments/assets/3904d85b-4ba1-481a-bcab-721bacde1dfc" />

scanf 함수는 read와 달리 모든 바이트를 정해진 개수만큼 받는 것이 아닌, 포맷에 맞추어 입력받는다. " ", "\t", "\n"과 같은 바이트가 입력되기 전의 결과만을 입력받는다는 것이다.





