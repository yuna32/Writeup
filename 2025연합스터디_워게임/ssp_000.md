Dreamhack ssp_000
==============

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {
    long addr;
    long value;
    char buf[0x40] = {};

    initialize();


    read(0, buf, 0x80);

    printf("Addr : ");
    scanf("%ld", &addr);
    printf("Value : ");
    scanf("%ld", &value);

    *(long *)addr = value;

    return 0;
}
```

ssp_001 문제와 같이 카나리 보호 기법이 걸려있는데 이건 코드를 보면 카나리를 유출할 수 없어서 ssp_001 문제와 같은 방법으로 카나리를 우회하기는 어렵다.

그러나 코드에는 취약점이 따로 있다.


---------

## 취약점 분석

1.  **스택 버퍼 오버플로우:**
    `main` 함수 내의 `read(0, buf, 0x80);`
    * `buf` 배열은 `char buf[0x40]`으로 선언되어 64바이트(0x40)의 크기를 가진다.
    * 하지만 `read` 함수는 표준 입력(0)으로부터 최대 128바이트(0x80)를 읽어 `buf`에 저장하도록 되어 있다.
    * 사용자가 64바이트를 초과하는 데이터를 입력하면 `buf` 다음에 위치한 스택 메모리 영역, 특히 **카나리 값이 저장된 공간을 덮어쓸 수 있다.**

2.  **임의 메모리 쓰기 취약점:**
    `*(long *)addr = value;` 
    * 사용자로부터 `addr` (주소)과 `value` (값)을 입력받는다.
    * 그리고 입력받은 `addr`이 가리키는 메모리 위치에 `value`를 쓴다.
    * **이 부분은 입력값에 대한 검증이나 제한이 없다.** 이를 이용해서 프로그램의 어느 메모리 위치든 원하는 값을 쓸 수 있다. 
